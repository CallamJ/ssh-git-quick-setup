#!/bin/bash

USERNAME="$(whoami)"

# Git accounts configuration
# Format: "pattern:name:email"
ACCOUNTS=(
    "github-personal:John Doe:john@personal.com"
    "github-work:John Doe:john@company.com"
)

set -e # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Paths
HOME_PATH="$HOME"
HOOKS_PATH="$HOME/.git-hooks"
SSH_PATH="$HOME/.ssh"

# Helper functions
print_header() {
    echo -e "\n${BLUE}===================================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}===================================================${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ $1${NC}"
}

# Check if required commands exist
check_dependencies() {
    print_header "Checking Dependencies"

    local missing_deps=()

    if ! command -v git &>/dev/null; then
        missing_deps+=("git")
    fi

    if ! command -v ssh-keygen &>/dev/null; then
        missing_deps+=("ssh-keygen")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        print_info "Please install them and run this script again."
        exit 1
    fi

    print_success "All dependencies found"
}

# Create hooks directory
create_hooks_directory() {
    print_header "Step 1: Creating Global Git Hooks Directory"

    if [ -d "$HOOKS_PATH" ]; then
        print_warning "Hooks directory already exists: $HOOKS_PATH"
    else
        echo -e "${YELLOW}This script is about to create a directory at: $HOOKS_PATH${NC}"
        echo -e "${YELLOW}This directory will store Git hooks that automatically set your Git identity${NC}"
        echo -e "${YELLOW}based on the repository's remote URL.${NC}"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Setup cancelled by user."
            exit 1
        fi

        mkdir -p "$HOOKS_PATH"
        print_success "Created hooks directory: $HOOKS_PATH"
    fi
}

# Generate hook script content
generate_hook_script() {
    local script="#!/bin/sh
# Auto-generated by Git Multi-Account Setup Script
# Get the remote URL
remote_url=\$(git config --get remote.origin.url)

# Match against patterns and set user config accordingly
"

    local first=true
    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"

        if [ "$first" = true ]; then
            script+="if echo \"\$remote_url\" | grep -q \"$pattern\"; then
    git config user.name \"$name\"
    git config user.email \"$email\"
"
            first=false
        else
            script+="elif echo \"\$remote_url\" | grep -q \"$pattern\"; then
    git config user.name \"$name\"
    git config user.email \"$email\"
"
        fi
    done

    script+="fi

exit 0"

    echo "$script"
}

# Create pre-push hook
create_pre_push_hook() {
    print_header "Step 2: Creating Pre-Push Hook"

    local hook_file="$HOOKS_PATH/pre-push"

    echo -e "${YELLOW}This script is about to create a pre-push hook at: $hook_file${NC}"
    echo -e "${YELLOW}This hook will automatically verify and set your Git identity before each push.${NC}"
    echo -e "${YELLOW}This ensures you never push commits with the wrong account.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    generate_hook_script >"$hook_file"
    chmod +x "$hook_file"

    print_success "Created pre-push hook: $hook_file"
}

# Create pre-commit hook
create_pre_commit_hook() {
    print_header "Step 3: Creating Pre-Commit Hook"

    local hook_file="$HOOKS_PATH/pre-commit"

    echo -e "${YELLOW}This script is about to create a pre-commit hook at: $hook_file${NC}"
    echo -e "${YELLOW}This hook will automatically set your Git identity before each commit.${NC}"
    echo -e "${YELLOW}This prevents commits from being created with the wrong author information.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    generate_hook_script >"$hook_file"
    chmod +x "$hook_file"

    print_success "Created pre-commit hook: $hook_file"
}

# Create post-checkout hook
create_post_checkout_hook() {
    print_header "Step 4: Creating Post-Checkout Hook"

    local hook_file="$HOOKS_PATH/post-checkout"

    echo -e "${YELLOW}This script is about to create a post-checkout hook at: $hook_file${NC}"
    echo -e "${YELLOW}This hook will automatically set your Git identity after cloning or checking out branches.${NC}"
    echo -e "${YELLOW}This means you never have to manually configure your identity in new repositories.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    generate_hook_script >"$hook_file"
    chmod +x "$hook_file"

    print_success "Created post-checkout hook: $hook_file"
}

# Configure Git to use global hooks
configure_git_hooks() {
    print_header "Step 5: Configuring Git to Use Global Hooks"

    echo -e "${YELLOW}This script is about to modify your global Git configuration.${NC}"
    echo -e "${YELLOW}It will set 'core.hooksPath' to: $HOOKS_PATH${NC}"
    echo -e "${YELLOW}This tells Git to use the hooks we created for all repositories on this system.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    git config --global core.hooksPath "$HOOKS_PATH"

    print_success "Configured Git to use hooks from: $HOOKS_PATH"
}

# Add Git alias for manual setup
add_git_alias() {
    print_header "Step 6: Adding Git Alias for Manual Setup"

    echo -e "${YELLOW}This script is about to add a Git alias called 'set-identity'.${NC}"
    echo -e "${YELLOW}This will modify your global Git configuration.${NC}"
    echo -e "${YELLOW}After this, you can run 'git set-identity' in any repository to manually${NC}"
    echo -e "${YELLOW}trigger the identity-setting hook.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    git config --global alias.set-identity "!$HOOKS_PATH/post-checkout"

    print_success "Added 'git set-identity' alias"
    print_info "You can now run 'git set-identity' in any repo to manually set your identity"
}

# Generate SSH keys
generate_ssh_keys() {
    print_header "Step 7: Generating SSH Keys"

    echo -e "${YELLOW}This script is about to generate SSH keys in: $SSH_PATH${NC}"
    echo -e "${YELLOW}It will create one key pair for each account you configured.${NC}"
    echo -e "${YELLOW}These keys are necessary to authenticate with GitHub/GitLab using SSH.${NC}"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Setup cancelled by user."
        exit 1
    fi

    mkdir -p "$SSH_PATH"
    chmod 700 "$SSH_PATH"

    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"

        local key_name="${pattern//github-/}"
        key_name="${key_name//gitlab-/}"
        local key_path="$SSH_PATH/id_ed25519_$key_name"

        if [ -f "$key_path" ]; then
            print_warning "SSH key already exists: $key_path"
            echo -e "${YELLOW}Do you want to overwrite the existing key for $pattern?${NC}"
            echo -e "${YELLOW}Warning: This will invalidate the old key on GitHub/GitLab.${NC}"
            read -p "Overwrite? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_info "Skipping key generation for $pattern"
                continue
            fi
        fi

        print_info "Generating SSH key for $pattern ($email)..."
        ssh-keygen -t ed25519 -C "$email" -f "$key_path" -N ""

        print_success "Generated SSH key: $key_path"
    done
}

# Configure SSH
configure_ssh() {
    print_header "Step 8: Configuring SSH"

    local ssh_config="$SSH_PATH/config"
    local backup_config=""

    if [ -f "$ssh_config" ]; then
        backup_config="$ssh_config.backup.$(date +%s)"
        echo -e "${YELLOW}An SSH config file already exists at: $ssh_config${NC}"
        echo -e "${YELLOW}This script will append the new configuration to your existing file.${NC}"
        echo -e "${YELLOW}A backup will be created at: $backup_config${NC}"
        echo -e "${YELLOW}This is necessary to map your SSH host aliases to the correct keys.${NC}"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Setup cancelled by user."
            exit 1
        fi
        cp "$ssh_config" "$backup_config"
        print_success "Existing SSH config backed up to: $backup_config"
    else
        echo -e "${YELLOW}This script is about to create an SSH config file at: $ssh_config${NC}"
        echo -e "${YELLOW}This file maps your SSH host aliases (like github-personal) to the correct${NC}"
        echo -e "${YELLOW}SSH keys and GitHub/GitLab servers.${NC}"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Setup cancelled by user."
            exit 1
        fi
    fi

    # Generate SSH config
    local config_content="# Generated by Git Multi-Account Setup Script
# Generated on: $(date)

"

    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"

        local key_name="${pattern//github-/}"
        key_name="${key_name//gitlab-/}"
        local key_path="$SSH_PATH/id_ed25519_$key_name"

        config_content+="# $name ($email)
Host $pattern
    HostName github.com
    User git
    IdentityFile $key_path
    IdentitiesOnly yes

"
    done

    if [ -f "$ssh_config" ]; then
        echo "$config_content" >>"$ssh_config"
        print_success "Appended to existing SSH config: $ssh_config"
    else
        echo "$config_content" >"$ssh_config"
        chmod 600 "$ssh_config"
        print_success "Created SSH config: $ssh_config"
    fi
}

# Display public keys
display_public_keys() {
    print_header "Step 9: Add Public Keys to GitHub"

    echo -e "${YELLOW}Copy each public key and add it to the corresponding GitHub account:${NC}"
    echo -e "${YELLOW}GitHub → Settings → SSH and GPG keys → New SSH key${NC}\n"

    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"

        local key_name="${pattern//github-/}"
        key_name="${key_name//gitlab-/}"
        local pub_key_path="$SSH_PATH/id_ed25519_$key_name.pub"

        if [ -f "$pub_key_path" ]; then
            echo -e "${GREEN}========================================${NC}"
            echo -e "${GREEN}$name ($pattern)${NC}"
            echo -e "${GREEN}========================================${NC}"
            cat "$pub_key_path"
            echo -e "\n"
        else
            print_error "Public key not found: $pub_key_path"
        fi
    done

    read -p "Press Enter after you've added all public keys to GitHub..."
}

# Test SSH connections
test_ssh_connections() {
    print_header "Step 10: Testing SSH Connections"

    print_info "Testing each SSH connection (you may need to type 'yes' to accept host keys)...\n"

    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"

        echo -e "${BLUE}Testing $pattern...${NC}"
        if ssh -T "git@$pattern" 2>&1 | grep -q "successfully authenticated"; then
            print_success "$pattern connection successful"
        else
            print_warning "$pattern connection test completed (check output above)"
        fi
        echo
    done
}

# Display usage instructions
display_usage() {
    print_header "Setup Complete!"

    echo -e "${GREEN}Your multi-account Git setup is ready!${NC}\n"

    echo -e "${BLUE}How to use:${NC}"
    echo -e "  Clone repositories using the account pattern in the URL:\n"

    for account in "${ACCOUNTS[@]}"; do
        IFS=':' read -r pattern name email <<<"$account"
        echo -e "  ${YELLOW}$pattern:${NC}"
        echo -e "    git clone git@$pattern:username/repo.git\n"
    done

    echo -e "${BLUE}For existing repositories:${NC}"
    echo -e "  Update the remote URL:"
    echo -e "    git remote set-url origin git@PATTERN:username/repo.git\n"

    echo -e "${BLUE}Manual identity setup:${NC}"
    echo -e "  Run this in any repo to set identity based on remote URL:"
    echo -e "    git set-identity\n"

    echo -e "${BLUE}Automatic identity management:${NC}"
    echo -e "  ✓ post-checkout - Sets identity when cloning or switching branches"
    echo -e "  ✓ pre-commit - Ensures correct identity before commits"
    echo -e "  ✓ pre-push - Final check before pushing\n"

    echo -e "${GREEN}Triple protection means you'll never use the wrong account!${NC}\n"
}

# Main execution
main() {
    echo -e "${BLUE}"
    echo "==========================================="
    echo "  Git and SSH Multi-Account Setup Script"
    echo "==========================================="
    echo -e "${NC}\n"

    if [ ${#ACCOUNTS[@]} -eq 0 ]; then
        print_error "No accounts configured."
        exit 1
    fi

    check_dependencies
    create_hooks_directory
    create_pre_push_hook
    create_pre_commit_hook
    create_post_checkout_hook
    configure_git_hooks
    add_git_alias
    generate_ssh_keys
    configure_ssh
    display_public_keys
    test_ssh_connections
    display_usage
}

# Run main function
main
